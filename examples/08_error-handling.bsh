// ============================================
// File: examples/08_error-handling.bsh
// Error handling with try-catch
// ============================================


// ---------------
// Basic Try-Catch
// ---------------

try
    let result = cmd("cat", "nonexistent.txt")
    if result.code != 0
        throw "File read failed"
    end
catch err
    print($"Error: {err.message}")
end


// ---------------
// Error Object Structure
// ---------------

struct Error
    message: string
    code: int?
end


// ---------------
// Functions that Throw
// ---------------

fn divide(a: int, b: int): float
    if b == 0
        throw "Division by zero"
    end
    return a / b
end

try
    let result = divide(10, 0)
    print(result)
catch err
    print($"Caught error: {err.message}")
    if err.code != null
        print($"Error code: {err.code}")
    end
end


// ---------------
// Nested Try-Catch
// ---------------

try
    try
        run("dangerous_command")
    catch inner_err
        print($"Inner error: {inner_err.message}")
        throw "Failed to recover"
    end
catch outer_err
    print($"Outer error: {outer_err.message}")
end


// ---------------
// Safe Shell Commands
// ---------------

fn safe_read_file(path: string): string?
    try
        let result = cmd("cat", path)
        if result.code == 0
            return result.stdout
        end
        return null
    catch err
        print($"Failed to read {path}: {err.message}")
        return null
    end
end

let content = safe_read_file("data.txt")
let data = content ?? "No data available"

