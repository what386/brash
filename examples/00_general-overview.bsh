// ============================================
// File: examples/00_general-overview.bsh
// Quick reference guide to current Brash syntax
// ============================================

// Variables and mutability
let x = 5
let mut y = 10
const PI = 3.14159
y = 15

// Types and nullability
let name: string = "Alice"
let mut middle_name: string? = null
middle_name = "Jane"
let display_name = middle_name ?? "No middle name"
let count_as_text = 5 as string

// Functions
fn greet(name: string, greeting: string = "Hello"): string
    return greeting + ", " + name
end

fn increment(mut count: int): int
    count = count + 1
    return count
end

// Tuple returns + tuple destructuring with per-element mutability
fn pair(): (string, string)
    return ("left", "right")
end

let (mut thing, otherthing) = pair()
thing = "updated"
// otherthing = "nope" // immutable by default

// Control flow
if x > 0
    println!("positive")
end

for i in 0..10 step 2
    println!(i as string)
end

let mut counter = 0
while counter < 3
    counter = counter + 1
end

// Structs, enums, impl
enum AccountType
    Checking,
    Savings
end

struct Person
    name: string
    age: int
    account: AccountType
end

impl Person
    fn is_adult(): bool
        return self.age >= 18
    end
end

let person = Person { name: "Alice", age: 30, account: AccountType.Checking }
println!(person.is_adult() as string)

// Command model
let pipeline = cmd("printf", "abc\n") | cmd("tr", "a-z", "A-Z")
let output = exec(pipeline)
println!(output)

let pid: Process = spawn("sleep", "1")
println!(pid as string)

// Error handling
try
    throw "boom"
catch err
    // catch variable currently contains textual stderr
    println!(err as string)
end

// Preprocessor directives
#define DEBUG 1
#if DEBUG
println!("debug enabled")
#endif

// Not yet transpilation-ready (kept for future versions):
// - import resolution
// - async/await execution model
